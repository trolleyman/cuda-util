
use std::io::prelude::*;
use std::io::{self, SeekFrom};
use std::borrow::Cow;

use chrono::Local;

use super::{FunctionType, conv};
use super::file::*;


pub enum TransError {
	IoError(io::Error),
	SynError(syn::Error),
}
impl From<io::Error> for TransError {
	fn from(e: io::Error) -> Self {
		TransError::IoError(e)
	}
}
impl From<syn::Error> for TransError {
	fn from(e: syn::Error) -> Self {
		TransError::SynError(e)
	}
}

/// Write header file source code to file
pub fn write_fn_header_file<F: FileLike>(of: &mut F, f: &syn::ItemFn, fn_type: FunctionType) -> Result<(), TransError> {
	// Check if file hasn't got header
	if of.seek(SeekFrom::End(0))? == 0 {
		write_header_intro(of)?;
	}

	// Write function
	write_fn_decl(of, f, fn_type, true)?;
	writeln!(of, ";")?;
	write_fn_decl(of, f, fn_type, false)?;
	writeln!(of, ";")?;
	Ok(())
}

/// Write start of header file into `of`
fn write_header_intro(of: &mut FileLike) -> Result<(), TransError> {
	writeln!(of, "/* Generated by cuda-macros https://github.com/trolleyman/cuda-macros on {} */", Local::now().to_rfc2822())?;
	writeln!(of, "{}", r#"
#pragma once

#include <cstdint>

#include <cuda_runtime.h>

typedef struct {
	uint32_t grid_size[3];
	uint32_t block_size[3];
	uint32_t shared_mem_size;
	cudaStream_t cuda_stream;
} rust_cuda_macros_execution_config_t;

"#)?;
	Ok(())
}

/// Write function to file
pub fn write_fn_cu_file<F: FileLike>(of: &mut F, f: &syn::ItemFn, fn_type: FunctionType) -> Result<(), TransError> {
	writeln!(of, "/* Generated by cuda-macros https://github.com/trolleyman/cuda-macros on {} */", Local::now().to_rfc2822())?;
	writeln!(of, "")?;
	writeln!(of, "#include <cstdint>")?;
	writeln!(of, "#include <rust_cuda_macros_header.h>")?;
	writeln!(of, "")?;

	// Write wrapper function
	write_fn_decl(of, f, fn_type, true)?;
	writeln!(of, " {{")?;
	write_wrapper_fn_body(of, f)?;
	writeln!(of, "}}")?;

	// Write CUDA function
	write_fn_decl(of, f, fn_type, false)?;
	writeln!(of, " {{")?;
	write_cuda_fn_body(of, &f.block.stmts)?;
	writeln!(of, "}}")?;
	Ok(())
}

/// Write function declaration
fn write_fn_decl<F: FileLike>(of: &mut F, f: &syn::ItemFn, fn_type: FunctionType, is_wrapper: bool) -> Result<(), TransError> {
	let ret: Cow<'static, str> = match &f.decl.output {
		syn::ReturnType::Default => "void".into(),
		syn::ReturnType::Type(_, ty) => conv::rust_type_to_c(&ty)
			.map_err(|e| e.unwrap_or_else(|| syn::Error::new_spanned(ty, "invalid return type")))?,
	};
	if fn_type == FunctionType::Global && ret != "void" {
		return Err(syn::Error::new_spanned(f.decl.output.clone(), "invalid return type: #[global] functions must return nothing"))?;
	}
	let mut args = vec![];
	if is_wrapper {
		// Add ExecutionConfig argument
		args.push("rust_cuda_macros_execution_config_t rust_cuda_macros_config".into());
	}
	for arg in f.decl.inputs.iter() {
		if let Some((ty, ident)) = conv::rust_fn_arg_to_c(&arg)? {
			args.push(format!("{} {}", ty, ident));
		}
	}
	let args = args.join(", ");
	let fn_ident = if is_wrapper {
		format!("rust_cuda_macros_wrapper_{}", &f.ident)
	} else {
		format!("{}", &f.ident)
	};
	write!(of, "{} {} {}({})", fn_type.cattr(), ret, fn_ident, args)?;
	Ok(())
}

/// Wrapper function body: all this does is call the CUDA function
fn write_wrapper_fn_body<F: FileLike>(of: &mut F, f: &syn::ItemFn) -> Result<(), TransError> {
	let mut args = vec![];
	for arg in f.decl.inputs.iter() {
		if let Some((_, ident)) = conv::rust_fn_arg_to_c(&arg)? {
			args.push(format!("{}", ident));
		}
	}
	let args = args.join(", ");
	writeln!(of, "\tdim3 rust_cuda_macros_grid_size = ;")?;
	writeln!(of, "\tdim3 rust_cuda_macros_block_size = ;")?;
	writeln!(of, "\t\tdim3(rust_cuda_macros_config.grid_size[0], rust_cuda_macros_config.grid_size[1], rust_cuda_macros_config.grid_size[2]),")?;
	writeln!(of, "\t\tdim3(rust_cuda_macros_config.block_size[0], rust_cuda_macros_config.block_size[1], rust_cuda_macros_config.block_size[2]),")?;
	writeln!(of, "\t\trust_cuda_macros_config.shared_mem_size,")?;
	writeln!(of, "\t\trust_cuda_macros_execution_config.cuda_stream")?;
	writeln!(of, "\t>>>{}({})", &f.ident, args)?;
	Ok(())
}

fn write_cuda_fn_body<F: FileLike>(of: &mut F, stmts: &[syn::Stmt]) -> Result<(), TransError> {
	for (i, stmt) in stmts.iter().enumerate() {
		write_stmt(FileLikeIndent::new(of, 1), stmt, i == stmts.len())?;
	}
	Ok(())
}

fn write_stmt<F: FileLike>(mut of: FileLikeIndent<F>, stmt: &syn::Stmt, is_last: bool) -> Result<(), TransError> {
	use syn::{Pat, Stmt};

	match stmt {
		Stmt::Local(local) => {
			let enabled = conv::is_item_enabled(&local.attrs, conv::CfgType::DeviceCode)?;
			if enabled {
				if local.pats.len() != 1 {
					Err(syn::Error::new_spanned(local.pats.clone(), "invalid pattern: only simple identifier allowed"))?;
				}
				let pat = &local.pats[0];
				let (ident, mutability) = match pat {
					Pat::Ident(pident) if pident.by_ref == None && pident.subpat == None => {
						(pident.ident.to_string(), pident.mutability.is_some())
					},
					_ => return Err(syn::Error::new_spanned(local.pats.clone(), "invalid pattern: only simple identifier allowed").into()),
				};
				if local.ty.is_none() {
					return Err(syn::Error::new_spanned(local.clone(), "inferred types are not supported").into());
				}
				let ty = &local.ty.as_ref().unwrap();
				let cty = conv::rust_type_to_c(&ty.1)
					.map_err(|e| e.unwrap_or(syn::Error::new_spanned(ty.1.clone(), "invalid type")))?;
				write!(of.incr(), "{} ", cty)?;
				if !mutability {
					write!(&mut of, "const ")?;
				}
				write!(&mut of, "{}", ident)?;
				if let Some((_, init)) = &local.init {
					write!(&mut of, " = ")?;
					write_expr(of.incr(), &init)?;
				}
				writeln!(&mut of, ";")?;
			}
		},
		Stmt::Item(item) => {
			/*
			match item {
				// TODO: syn::Item::Struct => {},
				// TODO: syn::Item::Enum => {},
				// TODO: syn::Item::Union => {},
			}*/
			Err(syn::Error::new_spanned(item.clone(), "item not allowed"))?;
		},
		Stmt::Expr(e) if is_last => {
			write!(&mut of, "return ")?;
			write_expr(of.incr(), &e)?;
			write!(&mut of, ";")?;
		},
		Stmt::Expr(e) => Err(syn::Error::new_spanned(e.clone(), "missed semicolon"))?,
		Stmt::Semi(e, _) => {
			write_expr(of.clone(), &e)?;
			writeln!(&mut of, ";")?;
		}
	}
	Ok(())
}

fn write_expr<F: FileLike>(mut of: FileLikeIndent<F>, e: &syn::Expr) -> Result<(), TransError> {
	use syn::Expr;

	match e {
		Expr::Box(e) => Err(syn::Error::new_spanned(e.clone(), "box expressions are not supported"))?,
		Expr::InPlace(e) => Err(syn::Error::new_spanned(e.clone(), "placement expressions are not supported"))?,
		Expr::Array(_e) => {
			unimplemented!(); // TODO
		},
		Expr::Call(_e) => {
			unimplemented!(); // TODO
		},
		Expr::MethodCall(e) => Err(syn::Error::new_spanned(e.clone(), "method call expressions are not supported"))?,
		Expr::Tuple(e) => Err(syn::Error::new_spanned(e.clone(), "tuple expressions are not supported"))?,
		Expr::Binary(_e) => {
			unimplemented!(); // TODO
		},
		Expr::Unary(_e) => {
			unimplemented!(); // TODO
		},
		Expr::Lit(_e) => {
			unimplemented!(); // TODO
		},
		Expr::Cast(_e) => {
			unimplemented!(); // TODO
		},
		Expr::Type(e) => Err(syn::Error::new_spanned(e.clone(), "type ascription is not supported"))?,
		Expr::Let(e) => Err(syn::Error::new_spanned(e.clone(), "let guards are not supported"))?,
		Expr::If(_e) => {
			unimplemented!(); // TODO
		},
		Expr::While(_e) => {
			unimplemented!(); // TODO
		},
		Expr::ForLoop(_e) => {
			unimplemented!(); // TODO
		},
		Expr::Loop(_e) => {
			unimplemented!(); // TODO
		},
		Expr::Match(e) => {
			// TODO
			Err(syn::Error::new_spanned(e.clone(), "match expressions are not supported, but potentially will be in the future"))?
		},
		Expr::Closure(e) => Err(syn::Error::new_spanned(e.clone(), "closures are not supported"))?,
		Expr::Unsafe(e) => Err(syn::Error::new_spanned(e.clone(), "unsafe blocks are not supported"))?,
		Expr::Block(_e) => {
			unimplemented!(); // TODO
		},
		Expr::Assign(_e) => {
			unimplemented!(); // TODO
		},
		Expr::AssignOp(_e) => {
			unimplemented!(); // TODO
		},
		Expr::Field(_e) => {
			unimplemented!(); // TODO
		},
		Expr::Index(_e) => {
			unimplemented!(); // TODO
		},
		Expr::Range(e) => Err(syn::Error::new_spanned(e.clone(), "range expressions are not supported"))?,
		Expr::Path(e) => Err(syn::Error::new_spanned(e.clone(), "paths are not supported"))?,
		Expr::Reference(_e) => {
			unimplemented!(); // TODO
		},
		Expr::Break(_e) => {
			unimplemented!(); // TODO
		},
		Expr::Continue(_e) => {
			unimplemented!(); // TODO
		},
		Expr::Return(_e) => {
			unimplemented!(); // TODO
		},
		Expr::Macro(e) => Err(syn::Error::new_spanned(e.clone(), "macros are not supported"))?,
		Expr::Struct(_e) => {
			unimplemented!(); // TODO
		},
		Expr::Repeat(_e) => {
			unimplemented!(); // TODO
		},
		Expr::Paren(syn::ExprParen{attrs, expr, ..}) | Expr::Group(syn::ExprGroup{attrs, expr, ..}) => {
			if conv::is_item_enabled(attrs, conv::CfgType::DeviceCode)? {
				write!(&mut of, "(")?;
				write_expr(of.incr(), expr)?;
				write!(&mut of, ")")?;
			}
		},
		Expr::Try(e) => Err(syn::Error::new_spanned(e.clone(), "try expressions are not supported"))?,
		Expr::Async(e) => Err(syn::Error::new_spanned(e.clone(), "async is not supported"))?,
		Expr::TryBlock(e) => Err(syn::Error::new_spanned(e.clone(), "try blocks are not supported"))?,
		Expr::Yield(e) => Err(syn::Error::new_spanned(e.clone(), "yield is not supported"))?,
		Expr::Verbatim(e) => Err(syn::Error::new_spanned(e.clone(), "unknown expression"))?,
	}
	Ok(())
}
