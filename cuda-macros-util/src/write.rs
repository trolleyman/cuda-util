
use std::io::prelude::*;
use std::io::{self, SeekFrom};
use std::borrow::Cow;

use chrono::Local;

use super::{FunctionType, conv};
use super::file::*;


pub enum TransError {
	IoError(io::Error),
	SynError(syn::Error),
}
impl From<io::Error> for TransError {
	fn from(e: io::Error) -> Self {
		TransError::IoError(e)
	}
}
impl From<syn::Error> for TransError {
	fn from(e: syn::Error) -> Self {
		TransError::SynError(e)
	}
}

/// Write header file source code to file
pub fn write_fn_header_file<F: FileLike>(of: &mut F, f: &syn::ItemFn, fn_type: FunctionType) -> Result<(), TransError> {
	// Check if file hasn't got header
	if of.seek(SeekFrom::End(0))? == 0 {
		write_header_intro(of)?;
	}

	// Write function
	write_fn_decl(of, f, fn_type, true)?;
	writeln!(of, ";")?;
	write_fn_decl(of, f, fn_type, false)?;
	writeln!(of, ";")?;
	Ok(())
}

/// Write start of header file into `of`
fn write_header_intro(of: &mut FileLike) -> Result<(), TransError> {
	writeln!(of, "/* Generated by cuda-macros https://github.com/trolleyman/cuda-macros on {} */", Local::now().to_rfc2822())?;
	writeln!(of, "{}", r#"#pragma once

#include <stdint.h>
#include <stdbool.h>

#include <cuda_runtime.h>

#ifdef __cplusplus
#define EXTERN_C extern "C"
#else
#define EXTERN_C
#endif

typedef struct {
	uint32_t grid_size[3];
	uint32_t block_size[3];
	uint32_t shared_mem_size;
	cudaStream_t cuda_stream;
} rust_cuda_macros_execution_config_t;

"#)?;
	Ok(())
}

/// Write function to file
pub fn write_fn_cu_file<F: FileLike>(of: &mut F, f: &syn::ItemFn, fn_type: FunctionType) -> Result<(), TransError> {
	writeln!(of, "/* Generated by cuda-macros https://github.com/trolleyman/cuda-macros on {} */", Local::now().to_rfc2822())?;
	writeln!(of, "")?;
	writeln!(of, "#include <cstdio>")?;
	writeln!(of, "#include <rust_cuda_macros_header.h>")?;
	writeln!(of, "")?;

	// Write wrapper function
	write_fn_decl(of, f, fn_type, true)?;
	writeln!(of, " {{")?;
	write_wrapper_fn_body(of, f)?;
	writeln!(of, "}}")?;

	// Write CUDA function
	write_fn_decl(of, f, fn_type, false)?;
	writeln!(of, " {{")?;
	write_cuda_fn_body(of, &f.block.stmts)?;
	writeln!(of, "}}")?;
	Ok(())
}

/// Write function declaration, e.g. `void hello()`
fn write_fn_decl<F: FileLike>(of: &mut F, f: &syn::ItemFn, fn_type: FunctionType, is_wrapper: bool) -> Result<(), TransError> {
	let ret: Cow<'static, str> = match &f.decl.output {
		syn::ReturnType::Default => "void".into(),
		syn::ReturnType::Type(_, ty) => conv::rust_type_to_c(&ty)
			.map_err(|e| e.unwrap_or_else(|| syn::Error::new_spanned(ty, "invalid return type")))?,
	};
	if fn_type == FunctionType::Global && ret != "void" {
		return Err(syn::Error::new_spanned(f.decl.output.clone(), "invalid return type: #[global] functions must return nothing"))?;
	}
	let mut args = vec![];
	if is_wrapper {
		// Add ExecutionConfig argument
		args.push("rust_cuda_macros_execution_config_t rust_cuda_macros_config".into());
	}
	for arg in f.decl.inputs.iter() {
		if let Some((ty, ident)) = conv::rust_fn_arg_to_c(&arg)? {
			args.push(format!("{} {}", ty, ident));
		}
	}
	let args = args.join(", ");
	let fn_ident = if is_wrapper {
		format!("rust_cuda_macros_wrapper_{}", &f.ident)
	} else {
		format!("{}", &f.ident)
	};
	let attr = if is_wrapper { "".into() } else { format!("{} ", fn_type.cattr()) };
	write!(of, "EXTERN_C {}{} {}({})", attr, ret, fn_ident, args)?;
	Ok(())
}

/// Wrapper function body: all this does is call the CUDA function
fn write_wrapper_fn_body<F: FileLike>(of: &mut F, f: &syn::ItemFn) -> Result<(), TransError> {
	let mut args = vec![];
	for arg in f.decl.inputs.iter() {
		if let Some((_, ident)) = conv::rust_fn_arg_to_c(&arg)? {
			args.push(format!("{}", ident));
		}
	}
	let args = args.join(", ");
	writeln!(of, "\treturn {}<<<", &f.ident)?;
	writeln!(of, "\t\tdim3(rust_cuda_macros_config.grid_size[0], rust_cuda_macros_config.grid_size[1], rust_cuda_macros_config.grid_size[2]),")?;
	writeln!(of, "\t\tdim3(rust_cuda_macros_config.block_size[0], rust_cuda_macros_config.block_size[1], rust_cuda_macros_config.block_size[2]),")?;
	writeln!(of, "\t\trust_cuda_macros_config.shared_mem_size,")?;
	writeln!(of, "\t\trust_cuda_macros_config.cuda_stream")?;
	writeln!(of, "\t>>>({});", args)?;
	Ok(())
}

fn write_cuda_fn_body<F: FileLike>(of: &mut F, stmts: &[syn::Stmt]) -> Result<(), TransError> {
	write_stmts(FileLikeIndent::new(of, 1), stmts)
}

fn write_stmts<F: FileLike>(mut of: FileLikeIndent<F>, stmts: &[syn::Stmt]) -> Result<(), TransError> {
	for (i, stmt) in stmts.iter().enumerate() {
		write_stmt(of.clone(), stmt, i == stmts.len())?;
	}
	Ok(())
}

fn expr_requires_brackets(e: &syn::Expr) -> bool {
	use syn::Expr;

	match e {
		Expr::Path(_) | Expr::Field(_) | Expr::Lit(_) => false,
		_ => true
	}
}

fn write_stmt<F: FileLike>(mut of: FileLikeIndent<F>, stmt: &syn::Stmt, is_last: bool) -> Result<(), TransError> {
	use syn::{Pat, Stmt};

	match stmt {
		Stmt::Local(local) => {
			let enabled = conv::is_item_enabled(&local.attrs, conv::CfgType::DeviceCode)?;
			if enabled {
				if local.pats.len() != 1 {
					Err(syn::Error::new_spanned(local.pats.clone(), "invalid pattern: only simple identifier allowed"))?;
				}
				let pat = &local.pats[0];
				let (ident, mutability) = match pat {
					Pat::Ident(pident) if pident.by_ref == None && pident.subpat == None => {
						(pident.ident.to_string(), pident.mutability.is_some())
					},
					_ => return Err(syn::Error::new_spanned(local.pats.clone(), "invalid pattern: only simple identifier allowed").into()),
				};
				if local.ty.is_none() {
					return Err(syn::Error::new_spanned(local.clone(), "inferred types are not supported").into());
				}
				let ty = &local.ty.as_ref().unwrap();
				let cty = conv::rust_type_to_c(&ty.1)
					.map_err(|e| e.unwrap_or(syn::Error::new_spanned(ty.1.clone(), "invalid type")))?;
				write!(&mut of, "{} ", cty)?;
				if !mutability {
					write!(&mut of, "const ")?;
				}
				write!(&mut of, "{}", ident)?;
				if let Some((_, init)) = &local.init {
					write!(&mut of, " = ")?;
					write_expr(of.clone(), &init)?;
				}
				writeln!(&mut of, ";")?;
			}
		},
		Stmt::Item(item) => {
			/*
			match item {
				// TODO: syn::Item::Struct => {},
				// TODO: syn::Item::Enum => {},
				// TODO: syn::Item::Union => {},
			}*/
			Err(syn::Error::new_spanned(item.clone(), "item not allowed"))?;
		},
		Stmt::Expr(e) if is_last => {
			write!(&mut of, "return ")?;
			write_expr(of.clone(), &e)?;
			write!(&mut of, ";")?;
		},
		Stmt::Expr(e) => write_expr(of.clone(), &e)?,// TODO: figure out how this works Err(syn::Error::new_spanned(e.clone(), "missed semicolon"))?,
		Stmt::Semi(e, _) => {
			write_expr(of.clone(), &e)?;
			writeln!(&mut of, ";")?;
		}
	}
	Ok(())
}

fn write_expr_brackets_if_required<F: FileLike>(mut of: FileLikeIndent<F>, e: &syn::Expr) -> Result<(), TransError> {
	let brackets = expr_requires_brackets(e);
	if brackets {
		write!(&mut of, "(")?;
	}
	write_expr(of.clone(), e)?;
	if brackets {
		write!(&mut of, ")")?;
	}
	Ok(())
}

fn write_expr<F: FileLike>(mut of: FileLikeIndent<F>, e: &syn::Expr) -> Result<(), TransError> {
	use syn::{UnOp, Expr, Member};

	match e {
		Expr::Box(e) => Err(syn::Error::new_spanned(e.clone(), "box expressions are not supported"))?,
		Expr::InPlace(e) => Err(syn::Error::new_spanned(e.clone(), "placement expressions are not supported"))?,
		Expr::Array(e) => {
			if conv::is_item_enabled(&e.attrs, conv::CfgType::DeviceCode)? {
				write!(&mut of, "[")?;
				for (i, elem) in e.elems.iter().enumerate() {
					write_expr(of.clone(), &elem)?;
					if i < e.elems.len() - 1 {
						write!(&mut of, ",")?;
					}
				}
				write!(&mut of, "]")?;
			}
		},
		Expr::Call(e) => {
			if conv::is_item_enabled(&e.attrs, conv::CfgType::DeviceCode)? {
				write_expr_brackets_if_required(of.clone(), &*e.func)?;
				write!(&mut of, "(")?;
				for (i, elem) in e.args.iter().enumerate() {
					write_expr(of.clone(), &elem)?;
					if i < e.args.len() - 1 {
						write!(&mut of, ", ")?;
					}
				}
				write!(&mut of, ")")?;
			}
		},
		Expr::MethodCall(e) =>{
			if conv::is_item_enabled(&e.attrs, conv::CfgType::DeviceCode)? {
				if e.turbofish.is_some() {
					Err(syn::Error::new_spanned(e.turbofish.clone(), "generic methods are not supported"))?;
				}
				write_expr_brackets_if_required(of.clone(), &*e.receiver)?;
				write!(&mut of, ",")?;
				write!(&mut of, "{}", &e.method)?;
				write!(&mut of, "(")?;
				for (i, elem) in e.args.iter().enumerate() {
					write_expr(of.clone(), &elem)?;
					if i < e.args.len() - 1 {
						write!(&mut of, ", ")?;
					}
				}
				write!(&mut of, ")")?;
			}
		},
		Expr::Tuple(e) => Err(syn::Error::new_spanned(e.clone(), "tuple expressions are not supported"))?,
		Expr::Binary(e) => {
			if conv::is_item_enabled(&e.attrs, conv::CfgType::DeviceCode)? {
				write_expr_brackets_if_required(of.clone(), &*e.left)?;
				write!(&mut of, " ")?;
				write_binop(of.clone(), &e.op)?;
				write!(&mut of, " ")?;
				write_expr_brackets_if_required(of.clone(), &*e.left)?;
			}
		},
		Expr::Unary(e) => {
			if conv::is_item_enabled(&e.attrs, conv::CfgType::DeviceCode)? {
				let op = match &e.op {
					UnOp::Deref(_) => '*',
					UnOp::Not(_) => '!',
					UnOp::Neg(_) => '-',
				};
				write!(&mut of, "{}", op)?;
				write_expr(of.clone(), &*e.expr)?;
			}
		},
		Expr::Lit(e) => {
			if conv::is_item_enabled(&e.attrs, conv::CfgType::DeviceCode)? {
				write_lit(of.clone(), &e.lit)?;
			}
		},
		Expr::Cast(_e) => {
			unimplemented!("Expr::Cast"); // TODO
		},
		Expr::Type(e) => Err(syn::Error::new_spanned(e.clone(), "type ascription is not supported"))?,
		Expr::Let(e) => Err(syn::Error::new_spanned(e.clone(), "let guards are not supported"))?,
		Expr::If(_e) => {
			unimplemented!("Expr::If"); // TODO
		},
		Expr::While(_e) => {
			unimplemented!("Expr::While"); // TODO
		},
		Expr::ForLoop(_e) => {
			unimplemented!("Expr::ForLoop"); // TODO
		},
		Expr::Loop(_e) => {
			unimplemented!("Expr::Loop"); // TODO
		},
		Expr::Match(e) => {
			// TODO
			Err(syn::Error::new_spanned(e.clone(), "match expressions are not supported, but potentially will be in the future"))?
		},
		Expr::Closure(e) => Err(syn::Error::new_spanned(e.clone(), "closures are not supported"))?,
		Expr::Unsafe(e) => Err(syn::Error::new_spanned(e.clone(), "unsafe blocks are not supported"))?,
		Expr::Block(e) => {
			if conv::is_item_enabled(&e.attrs, conv::CfgType::DeviceCode)? {
				writeln!(&mut of, "{{")?;
				write_stmts(of.incr(), &e.block.stmts)?;
				writeln!(&mut of, "}}")?;
			}
		},
		Expr::Assign(e) => {
			if conv::is_item_enabled(&e.attrs, conv::CfgType::DeviceCode)? {
				write_expr(of.clone(), &e.left)?;
				write!(&mut of, " = ")?;
				write_expr(of.clone(), &e.right)?;
			}
		},
		Expr::AssignOp(_e) => {
			unimplemented!("Expr::AssignOp"); // TODO
		},
		Expr::Field(e) => {
			if conv::is_item_enabled(&e.attrs, conv::CfgType::DeviceCode)? {
				write_expr_brackets_if_required(of.clone(), &e.base)?;
				write!(&mut of, ".")?;
				match &e.member {
					Member::Unnamed(i) => Err(syn::Error::new_spanned(i.clone(), "unnamed field accesses are not supported"))?,
					Member::Named(name) => write!(&mut of, "{}", name)?,
				}
			}
		},
		Expr::Index(_e) => {
			unimplemented!("Expr::Index"); // TODO
		},
		Expr::Range(e) => Err(syn::Error::new_spanned(e.clone(), "range expressions are not supported"))?,
		Expr::Path(e) => {
			if conv::is_item_enabled(&e.attrs, conv::CfgType::DeviceCode)? {
				if e.qself.is_some() || e.path.leading_colon.is_some() || e.path.segments.len() != 1 {
					Err(syn::Error::new_spanned(e.clone(), "paths are not supported"))?;
				}
				let segment = &e.path.segments[0];
				if segment.arguments != syn::PathArguments::None {
					Err(syn::Error::new_spanned(e.clone(), "paths with generic arguments are not supported"))?;
				}
				write!(&mut of, "{}", &segment.ident)?;
			}
		},
		Expr::Reference(_e) => {
			unimplemented!("Expr::Reference"); // TODO
		},
		Expr::Break(_e) => {
			unimplemented!("Expr::Break"); // TODO
		},
		Expr::Continue(_e) => {
			unimplemented!("Expr::Continue"); // TODO
		},
		Expr::Return(_e) => {
			unimplemented!("Expr::Return"); // TODO
		},
		Expr::Macro(e) => Err(syn::Error::new_spanned(e.clone(), "macros are not supported"))?,
		Expr::Struct(_e) => {
			unimplemented!("Expr::Struct"); // TODO
		},
		Expr::Repeat(_e) => {
			unimplemented!("Expr::Repeat"); // TODO
		},
		Expr::Paren(syn::ExprParen{attrs, expr, ..}) | Expr::Group(syn::ExprGroup{attrs, expr, ..}) => {
			if conv::is_item_enabled(attrs, conv::CfgType::DeviceCode)? {
				write!(&mut of, "(")?;
				write_expr(of.clone(), expr)?;
				write!(&mut of, ")")?;
			}
		},
		Expr::Try(e) => Err(syn::Error::new_spanned(e.clone(), "try expressions are not supported"))?,
		Expr::Async(e) => Err(syn::Error::new_spanned(e.clone(), "async is not supported"))?,
		Expr::TryBlock(e) => Err(syn::Error::new_spanned(e.clone(), "try blocks are not supported"))?,
		Expr::Yield(e) => Err(syn::Error::new_spanned(e.clone(), "yield is not supported"))?,
		Expr::Verbatim(e) => Err(syn::Error::new_spanned(e.clone(), "unknown expression"))?,
	}
	Ok(())
}

fn write_binop<F: FileLike>(mut of: FileLikeIndent<F>, op: &syn::BinOp) -> Result<(), TransError> {
	use syn::BinOp::*;
	let op = match op {
		Add(_) => "+",
		Sub(_) => "-",
		Mul(_) => "*",
		Div(_) => "/",
		Rem(_) => "%",
		And(_) => "&&",
		Or(_) => "||",
		BitXor(_) => "^",
		BitAnd(_) => "&",
		BitOr(_) => "|",
		Shl(_) => "<<",
		Shr(_) => ">>",
		Eq(_) => "==",
		Lt(_) => "<",
		Le(_) => "<=",
		Ne(_) => "!=",
		Ge(_) => ">=",
		Gt(_) => ">",
		AddEq(_) => "+=",
		SubEq(_) => "-=",
		MulEq(_) => "*=",
		DivEq(_) => "/=",
		RemEq(_) => "%=",
		BitXorEq(_) => "^=",
		BitAndEq(_) => "&=",
		BitOrEq(_) => "|=",
		ShlEq(_) => "<<=",
		ShrEq(_) => ">>=",
	};
	write!(&mut of, "{}", op)?;
	Ok(())
}

fn write_lit<F: FileLike>(mut of: FileLikeIndent<F>, lit: &syn::Lit) -> Result<(), TransError> {
	use syn::Lit::*;
	use syn::{IntSuffix, FloatSuffix};
	match lit {
		Str(lit) => write_string_lit(of.clone(), lit.span(), &lit.value())?,
		ByteStr(lit) => write_string_lit(of.clone(), lit.span(), &lit.value().iter().map(|&c| c as char).collect::<String>())?,
		Byte(lit) => write!(&mut of, "((char){}/*{:?}*/)", lit.value(), lit.value() as char)?,
		Char(lit) => write!(&mut of, "((uint32_t){}/*{:?}*/)", lit.value() as u32, lit.value())?,
		Int(lit) => {
			match lit.suffix() {
				IntSuffix::None  => write!(&mut of, "{}", lit.value())?,
				IntSuffix::I8    => write!(&mut of, "((int8_t){})", lit.value())?,
				IntSuffix::U8    => write!(&mut of, "((uint8_t){})", lit.value())?,
				IntSuffix::I16   => write!(&mut of, "((int16_t){})", lit.value())?,
				IntSuffix::U16   => write!(&mut of, "((uint16_t){})", lit.value())?,
				IntSuffix::I32   => write!(&mut of, "((int32_t){})", lit.value())?,
				IntSuffix::U32   => write!(&mut of, "((uint32_t){})", lit.value())?,
				IntSuffix::I64   => write!(&mut of, "((int64_t){})", lit.value())?,
				IntSuffix::U64   => write!(&mut of, "((uint64_t){})", lit.value())?,
				IntSuffix::I128  => Err(syn::Error::new_spanned(lit.clone(), "128-bit integers are not supported"))?,
				IntSuffix::U128  => Err(syn::Error::new_spanned(lit.clone(), "128-bit integers are not supported"))?,
				IntSuffix::Isize => write!(&mut of, "((isize_t){})", lit.value())?,
				IntSuffix::Usize => write!(&mut of, "((usize_t){})", lit.value())?,
			}
		},
		Float(lit) => {
			match lit.suffix() {
				FloatSuffix::None => write!(&mut of, "{}", lit.value())?,
				FloatSuffix::F32  => write!(&mut of, "((float){})", lit.value())?,
				FloatSuffix::F64  => write!(&mut of, "((double){})", lit.value())?,
			}
		},
		Bool(lit) => write!(&mut of, "{:?}", lit.value)?,
		Verbatim(lit) => Err(syn::Error::new_spanned(lit.clone(), "unparseable literal"))?,
	}
	Ok(())
}

fn write_string_lit<F: FileLike>(mut of: FileLikeIndent<F>, span: proc_macro2::Span, s: &str) -> Result<(), TransError> {
	write!(&mut of, "{}", '"')?;
	for c in s.chars() {
		match c {
			//'\''     => write!(&mut of, r#"\'"#)?,
			'"'      => write!(&mut of, r#"\""#)?,
			'\u{3F}' => write!(&mut of, "\\?")?,
			'\\'     => write!(&mut of, r#"\\"#)?,
			'\u{07}' => write!(&mut of, "\\a")?,
			'\u{08}' => write!(&mut of, "\\b")?,
			'\u{0C}' => write!(&mut of, "\\f")?,
			'\n'     => write!(&mut of, "\\n")?,
			'\r'     => write!(&mut of, "\\r")?,
			'\t'     => write!(&mut of, "\\t")?,
			'\u{0B}' => write!(&mut of, "\\v")?,
			'\u{7F}' => write!(&mut of, "\\x7F")?,  // DEL
			'\u{0}'  ..= '\u{1F}'  => write!(&mut of, "\\x{:02X}", c as u32)?,
			'\u{20}' ..= '\u{7E}'  => write!(&mut of, "{}", c)?,
			// TODO: Handle strings correctly -- "abc" => u8"abc", and b"abc" => "abc"
			_ => return Err(syn::Error::new(span, "non-ASCII string are not supported").into()),
		}
	}
	write!(&mut of, "{}", '"')?;
	Ok(())
}
