
use std::io::{self, Read, Write, Seek, SeekFrom};
use std::borrow::Cow;

use chrono::Local;

use super::{FunctionType, conv};


pub trait FileLike: Write + Read + Seek {}
impl<T> FileLike for T where T: Write + Read + Seek {}


pub enum TransError {
	IoError(io::Error),
	SynError(syn::Error),
}
impl From<io::Error> for TransError {
	fn from(e: io::Error) -> Self {
		TransError::IoError(e)
	}
}
impl From<syn::Error> for TransError {
	fn from(e: syn::Error) -> Self {
		TransError::SynError(e)
	}
}

/// Write header file source code to file
pub fn write_fn_header_file(of: &mut FileLike, f: &syn::ItemFn, fn_type: FunctionType) -> Result<(), TransError> {
	// Check if file hasn't got header
	if of.seek(SeekFrom::End(0))? == 0 {
		write_header_intro(of)?;
	}

	// Write function
	write_fn_decl(of, f, fn_type, true)?;
	writeln!(of, ";")?;
	write_fn_decl(of, f, fn_type, false)?;
	writeln!(of, ";")?;
	Ok(())
}

/// Write start of header file into `of`
fn write_header_intro(of: &mut FileLike) -> Result<(), TransError> {
	writeln!(of, "/* Generated by cuda-macros https://github.com/trolleyman/cuda-macros on {} */", Local::now().to_rfc2822())?;
	writeln!(of, "{}", r#"
#pragma once

#include <cstdint>

#include <cuda_runtime.h>

typedef struct {
	uint32_t grid_size[3];
	uint32_t block_size[3];
	uint32_t shared_mem_size;
	void *cuda_stream;
} rust_cuda_macros_execution_config_t;

"#)?;
	Ok(())
}

/// Write function to file
pub fn write_fn_src_file(of: &mut FileLike, f: &syn::ItemFn, fn_type: FunctionType) -> Result<(), TransError> {
	writeln!(of, "/* Generated by cuda-macros https://github.com/trolleyman/cuda-macros on {} */", Local::now().to_rfc2822())?;
	writeln!(of, "")?;
	writeln!(of, "#include <cstdint>")?;
	writeln!(of, "#include <rust_cuda_macros_header.h>")?;
	writeln!(of, "")?;

	// Write wrapper function
	write_fn_decl(of, f, fn_type, true)?;
	writeln!(of, " {{")?;
	write_wrapper_fn_body(of, f)?;
	writeln!(of, "}}")?;

	// Write CUDA function
	write_fn_decl(of, f, fn_type, false)?;
	writeln!(of, " {{")?;
	write_cuda_fn_body(of, &f.block.stmts)?;
	writeln!(of, "}}")?;
	Ok(())
}

/// Write function declaration
fn write_fn_decl(of: &mut FileLike, f: &syn::ItemFn, fn_type: FunctionType, is_wrapper: bool) -> Result<(), TransError> {
	let ret: Cow<'static, str> = match &f.decl.output {
		syn::ReturnType::Default => "void".into(),
		syn::ReturnType::Type(_, ty) => conv::rust_type_to_c(&ty)
			.map_err(|e| e.unwrap_or_else(|| syn::Error::new_spanned(ty, "invalid type for CUDA function")))?,
	};
	if fn_type == FunctionType::Global && ret != "void" {
		return Err(syn::Error::new_spanned(f.decl.output.clone(), "#[global] CUDA functions are not allowed to return a value"))?;
	}
	let mut args = vec![];
	if is_wrapper {
		// Add ExecutionConfig argument
		args.push("rust_cuda_macros_execution_config_t rust_cuda_macros_execution_config".into());
	}
	for arg in f.decl.inputs.iter() {
		if let Some((ty, ident)) = conv::rust_fn_arg_to_c(&arg)? {
			args.push(format!("{} {}", ty, ident));
		}
	}
	let args = args.join(", ");
	let fn_ident = if is_wrapper {
		format!("rust_cuda_macros_fn_{}", &f.ident)
	} else {
		format!("rust_cuda_macros_wrapper_{}", &f.ident)
	};
	write!(of, "{} {} {}({})", fn_type.cattr(), ret, fn_ident, args)?;
	Ok(())
}

/// Wrapper function body: all this does is call the CUDA function
fn write_wrapper_fn_body(of: &mut FileLike, f: &syn::ItemFn) -> Result<(), TransError> {
	// TODO
	unimplemented!();
	Ok(())
}

fn write_cuda_fn_body(of: &mut FileLike, stmts: &[syn::Stmt]) -> Result<(), TransError> {
	for (i, stmt) in stmts.iter().enumerate() {
		write_stmt(of, stmt, 1, i == stmts.len())?;
	}
	Ok(())
}

fn write_stmt(of: &mut FileLike, stmt: &syn::Stmt, indent: usize, is_last: bool) -> Result<(), TransError> {
	use syn::Stmt;

	match stmt {
		Stmt::Local(_) => unimplemented!(),
		Stmt::Item(_) => unimplemented!(),
		Stmt::Expr(_) => unimplemented!(),
		Stmt::Semi(_, _) => unimplemented!(),
	}
}
