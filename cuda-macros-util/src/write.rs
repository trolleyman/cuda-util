
use std::io::prelude::*;
use std::io::{self, SeekFrom};
use std::borrow::Cow;

use chrono::Local;

use super::{FunctionType, conv};
use super::file::*;


pub enum TransError {
	IoError(io::Error),
	SynError(syn::Error),
}
impl From<io::Error> for TransError {
	fn from(e: io::Error) -> Self {
		TransError::IoError(e)
	}
}
impl From<syn::Error> for TransError {
	fn from(e: syn::Error) -> Self {
		TransError::SynError(e)
	}
}

/// Write header file source code to file
pub fn write_fn_header_file(of: &mut FileLike, f: &syn::ItemFn, fn_type: FunctionType, fn_hash: &str) -> Result<(), TransError> {
	// Check if file hasn't got header
	if of.seek(SeekFrom::End(0))? == 0 {
		write_header_intro(of)?;
	}

	// Write function
	write_fn_decl(of, f, fn_type, fn_hash, true)?;
	writeln!(of, ";")?;
	write_fn_decl(of, f, fn_type, fn_hash, false)?;
	writeln!(of, ";")?;
	Ok(())
}

/// Write start of header file into `of`
fn write_header_intro(of: &mut FileLike) -> Result<(), TransError> {
	writeln!(of, "/* Generated by cuda-macros https://github.com/trolleyman/cuda-macros on {} */", Local::now().to_rfc2822())?;
	writeln!(of, "{}", r#"
#pragma once

#include <cstdint>

#include <cuda_runtime.h>

typedef struct {
	uint32_t grid_size[3];
	uint32_t block_size[3];
	uint32_t shared_mem_size;
	cudaStream_t cuda_stream;
} rust_cuda_macros_execution_config_t;

"#)?;
	Ok(())
}

/// Write function to file
pub fn write_fn_cu_file(of: &mut FileLike, f: &syn::ItemFn, fn_type: FunctionType, fn_hash: &str) -> Result<(), TransError> {
	writeln!(of, "/* Generated by cuda-macros https://github.com/trolleyman/cuda-macros on {} */", Local::now().to_rfc2822())?;
	writeln!(of, "")?;
	writeln!(of, "#include <cstdint>")?;
	writeln!(of, "#include <rust_cuda_macros_header.h>")?;
	writeln!(of, "")?;

	// Write wrapper function
	write_fn_decl(of, f, fn_type, fn_hash, true)?;
	writeln!(of, " {{")?;
	write_wrapper_fn_body(of, f, fn_hash)?;
	writeln!(of, "}}")?;

	// Write CUDA function
	write_fn_decl(of, f, fn_type, fn_hash, false)?;
	writeln!(of, " {{")?;
	write_cuda_fn_body(of, &f.block.stmts)?;
	writeln!(of, "}}")?;
	Ok(())
}

/// Write function declaration
fn write_fn_decl(of: &mut FileLike, f: &syn::ItemFn, fn_type: FunctionType, fn_hash: &str, is_wrapper: bool) -> Result<(), TransError> {
	let ret: Cow<'static, str> = match &f.decl.output {
		syn::ReturnType::Default => "void".into(),
		syn::ReturnType::Type(_, ty) => conv::rust_type_to_c(&ty)
			.map_err(|e| e.unwrap_or_else(|| syn::Error::new_spanned(ty, "invalid return type")))?,
	};
	if fn_type == FunctionType::Global && ret != "void" {
		return Err(syn::Error::new_spanned(f.decl.output.clone(), "invalid return type: #[global] functions must return nothing"))?;
	}
	let mut args = vec![];
	if is_wrapper {
		// Add ExecutionConfig argument
		args.push("rust_cuda_macros_execution_config_t rust_cuda_macros_config".into());
	}
	for arg in f.decl.inputs.iter() {
		if let Some((ty, ident)) = conv::rust_fn_arg_to_c(&arg)? {
			args.push(format!("{} {}", ty, ident));
		}
	}
	let args = args.join(", ");
	let fn_ident = if is_wrapper {
		format!("rust_cuda_macros_wrapper_{}_{}", &f.ident, fn_hash)
	} else {
		format!("rust_cuda_macros_fn_{}_{}", &f.ident, fn_hash)
	};
	write!(of, "{} {} {}({})", fn_type.cattr(), ret, fn_ident, args)?;
	Ok(())
}

/// Wrapper function body: all this does is call the CUDA function
fn write_wrapper_fn_body(of: &mut FileLike, f: &syn::ItemFn, fn_hash: &str) -> Result<(), TransError> {
	let mut args = vec![];
	for arg in f.decl.inputs.iter() {
		if let Some((_, ident)) = conv::rust_fn_arg_to_c(&arg)? {
			args.push(format!("{}", ident));
		}
	}
	let args = args.join(", ");
	writeln!(of, "\tdim3 rust_cuda_macros_grid_size = dim3(rust_cuda_macros_config.grid_size[0], rust_cuda_macros_config.grid_size[1], rust_cuda_macros_config.grid_size[2]);")?;
	writeln!(of, "\tdim3 rust_cuda_macros_block_size = dim3(rust_cuda_macros_config.block_size[0], rust_cuda_macros_config.block_size[1], rust_cuda_macros_config.block_size[2]);")?;
	writeln!(of, "\treturn rust_cuda_macros_fn_{}_{}<<<rust_cuda_macros_grid_size, rust_cuda_macros_block_size, rust_cuda_macros_config.shared_mem_size, rust_cuda_macros_execution_config.cuda_stream>>>({});", &f.ident, fn_hash, args)?;
	Ok(())
}

fn write_cuda_fn_body(of: &mut FileLike, stmts: &[syn::Stmt]) -> Result<(), TransError> {
	for (i, stmt) in stmts.iter().enumerate() {
		write_stmt(FileLikeIndent::new(of, 1), stmt, i == stmts.len())?;
	}
	Ok(())
}

fn write_stmt(mut of: FileLikeIndent, stmt: &syn::Stmt, is_last: bool) -> Result<(), TransError> {
	use syn::Stmt;

	match stmt {
		Stmt::Local(_) => unimplemented!(),
		Stmt::Item(_) => unimplemented!(),
		Stmt::Expr(e) if is_last => {
			write!(of, "return ")?;
			write_expr(of.incr(), &e)?;
			write!(of, ";")?;
		},
		Stmt::Expr(e) => Err(syn::Error::new_spanned(e.clone(), "missed semicolon"))?,
		Stmt::Semi(_, _) => unimplemented!(),
	}
	Ok(())
}

fn write_expr(mut of: FileLikeIndent, e: &syn::Expr) -> Result<(), TransError> {
	unimplemented!()
}
