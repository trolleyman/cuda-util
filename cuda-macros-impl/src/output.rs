
use std::collections::hash_map::DefaultHasher;
use std::fs::File;
use std::io;

use chrono::Local;

use cuda_macros_util::FunctionType;


fn output_fn(f: syn::ItemFn, fn_type: FunctionType) -> Option<TokenStream> {
	use cuda_macros_util::FunctionType::*;

	let dir = PathBuf::from(env!("CUDA_MACROS_OUT_DIR"));

	let mut hasher = DefaultHasher::new();
	f.hash(&mut hasher);
	let hash = hasher.finish();

	let fname = format!("{}_{:0x}.cu", f.ident, hash)
	let path = dir.join(fname);

	let attr = match fn_type {
		Host => "__host__",
		Device => "__device__",
		Global => "__global__",
	};

	let mut of = match File::create(path) {
		Ok(of) => of,
		Err(e) => return Some(syn::Error::new(f, format!("failed to create file `{}`: {}", path.display(), e))),
	};
	match write_fn(of, f, fn_type) {
		Ok(()) => None,
		Err(e) => Some(syn::Error::new(f, format!("failed to write function to file `{}`: {}", path.display(), e))),
	}
}

fn write_fn(of: File, f: syn::ItemFn, fn_type: FunctionType) -> io::Result<()> {
	writeln!(of, "/* Generated by cuda-macros https://github.com/trolleyman/cuda-macros on {} */", Local::now().to_rfc2822())?;
	writeln!(of, "")?;
	writeln!(of, "{}")?;
	// TODO
}

fn translate_to_c_type() -> Option<()> {
	// TODO
}